AWSTemplateFormatVersion: '2010-09-09'
Description: CI/CD pipeline (CodeStar Source Connection) for SAM Bulk Dataset Generator deploying to ECS Fargate

Parameters:
  ProjectName:
    Type: String
    Default: sam-bulk-gen
  GitHubOwner:
    Type: String
  GitHubRepo:
    Type: String
  GitHubBranch:
    Type: String
    Default: main
  ConnectionArn:
    Type: String
    Description: CodeStar Connections ARN for GitHub (created separately)
  ContainerCPU:
    Type: Number
    Default: 1024
  ContainerMemory:
    Type: Number
    Default: 2048
  DesiredCount:
    Type: Number
    Default: 1
  VpcId:
    Type: AWS::EC2::VPC::Id
  PublicSubnets:
    Type: List<AWS::EC2::Subnet::Id>
  ListenerArn:
    Type: String
  ContainerPort:
    Type: Number
    Default: 3000
  HealthCheckPath:
    Type: String
    Default: /api/backend/health
  DatasetsBucketName:
    Type: String
  OutputsBucketName:
    Type: String
  ModelsBucketName:
    Type: String
  JobsQueueArn:
    Type: String
  JobsQueueUrl:
    Type: String
  JobsTableArn:
    Type: String
  JobsTableName:
    Type: String
  SamCheckpointKey:
    Type: String
    Default: sam_vit_b.pth
    Description: S3 object key of the SAM checkpoint to auto-fetch

Resources:
  EcrRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub ${ProjectName}-api
      ImageTagMutability: IMMUTABLE
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /ecs/${ProjectName}-api
      RetentionInDays: 14
  TaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: ecs-tasks.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
  TaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: ecs-tasks.amazonaws.com }
            Action: sts:AssumeRole
      Policies:
        - PolicyName: data-access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: [s3:GetObject,s3:PutObject,s3:ListBucket]
                Resource:
                  - !Sub arn:aws:s3:::${DatasetsBucketName}
                  - !Sub arn:aws:s3:::${DatasetsBucketName}/*
                  - !Sub arn:aws:s3:::${OutputsBucketName}
                  - !Sub arn:aws:s3:::${OutputsBucketName}/*
                  - !Sub arn:aws:s3:::${ModelsBucketName}
                  - !Sub arn:aws:s3:::${ModelsBucketName}/*
              - Effect: Allow
                Action: [sqs:ReceiveMessage,sqs:DeleteMessage,sqs:GetQueueAttributes,sqs:SendMessage]
                Resource: !Ref JobsQueueArn
              - Effect: Allow
                Action: [dynamodb:PutItem,dynamodb:UpdateItem,dynamodb:GetItem,dynamodb:DescribeTable]
                Resource: !Ref JobsTableArn
  Cluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub ${ProjectName}-cluster
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub ${ProjectName}-tg
      Port: !Ref ContainerPort
      Protocol: HTTP
      VpcId: !Ref VpcId
      TargetType: ip
      HealthCheckEnabled: true
      HealthCheckIntervalSeconds: 30
      HealthCheckPath: !Ref HealthCheckPath
      HealthCheckProtocol: HTTP
      Matcher: { HttpCode: 200 }
  ListenerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      ListenerArn: !Ref ListenerArn
      Priority: 600
      Conditions:
        - Field: path-pattern
          Values: ["/*"]
      Actions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub ${ProjectName}-api
      Cpu: !Ref ContainerCPU
      Memory: !Ref ContainerMemory
      NetworkMode: awsvpc
      RequiresCompatibilities: [FARGATE]
      ExecutionRoleArn: !GetAtt TaskExecutionRole.Arn
      TaskRoleArn: !GetAtt TaskRole.Arn
      ContainerDefinitions:
        - Name: api
          Image: !Sub ${EcrRepository.RepositoryUri}:latest
          Essential: true
          PortMappings: [{ ContainerPort: !Ref ContainerPort, Protocol: tcp }]
          Environment:
            - { Name: FLASK_PORT, Value: "5001" }
            - { Name: PY_SERVICE_URL, Value: http://127.0.0.1:5001 }
            - { Name: WARM_MODEL, Value: "1" }
            - { Name: DATASETS_BUCKET, Value: !Ref DatasetsBucketName }
            - { Name: OUTPUTS_BUCKET, Value: !Ref OutputsBucketName }
            - { Name: MODELS_BUCKET, Value: !Ref ModelsBucketName }
            - { Name: SAM_CHECKPOINT_KEY, Value: !Ref SamCheckpointKey }
            - { Name: JOBS_QUEUE_URL, Value: !Ref JobsQueueUrl }
            - { Name: JOBS_TABLE, Value: !Ref JobsTableName }
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref LogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
  Service:
    Type: AWS::ECS::Service
    DependsOn: ListenerRule
    Properties:
      Cluster: !Ref Cluster
      DesiredCount: !Ref DesiredCount
      LaunchType: FARGATE
      ServiceName: !Sub ${ProjectName}-api
      TaskDefinition: !Ref TaskDefinition
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          Subnets: !Ref PublicSubnets
      LoadBalancers:
        - ContainerName: api
          ContainerPort: !Ref ContainerPort
          TargetGroupArn: !Ref TargetGroup
  ArtifactBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
  CodeBuildRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: codebuild.amazonaws.com }
            Action: sts:AssumeRole
      Policies:
        - PolicyName: build-inline
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: [logs:CreateLogGroup,logs:CreateLogStream,logs:PutLogEvents]
                Resource: '*'
              - Effect: Allow
                Action: [ecr:GetAuthorizationToken,ecr:BatchCheckLayerAvailability,ecr:CompleteLayerUpload,ecr:UploadLayerPart,ecr:InitiateLayerUpload,ecr:PutImage,ecr:BatchGetImage]
                Resource: '*'
              - Effect: Allow
                Action: [ecs:DescribeServices,ecs:DescribeTaskDefinition,ecs:RegisterTaskDefinition,ecs:UpdateService]
                Resource: '*'
              - Effect: Allow
                Action: iam:PassRole
                Resource: [!GetAtt TaskExecutionRole.Arn, !GetAtt TaskRole.Arn]
              - Effect: Allow
                Action: [s3:GetObject,s3:PutObject,s3:GetObjectVersion,s3:GetBucketAcl,s3:GetBucketLocation]
                Resource: '*'
  CodeBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub ${ProjectName}-build
      ServiceRole: !GetAtt CodeBuildRole.Arn
      Artifacts: { Type: CODEPIPELINE }
      Environment:
        ComputeType: BUILD_GENERAL1_MEDIUM
        Image: aws/codebuild/standard:7.0
        Type: LINUX_CONTAINER
        PrivilegedMode: true
        EnvironmentVariables:
          - { Name: REPOSITORY_URI, Value: !GetAtt EcrRepository.RepositoryUri }
          - { Name: TASK_DEFINITION_FAMILY, Value: !Sub ${ProjectName}-api }
          - { Name: CLUSTER_NAME, Value: !Ref Cluster }
          - { Name: SERVICE_NAME, Value: !Sub ${ProjectName}-api }
      Source: { Type: CODEPIPELINE }
      TimeoutInMinutes: 30
  PipelineRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: codepipeline.amazonaws.com }
            Action: sts:AssumeRole
      Policies:
        - PolicyName: pipeline-inline
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: [s3:GetObject,s3:PutObject,s3:GetObjectVersion,s3:GetBucketVersioning]
                Resource: '*'
              - Effect: Allow
                Action: [codebuild:BatchGetBuilds,codebuild:StartBuild]
                Resource: '*'
              - Effect: Allow
                Action: [codestar-connections:UseConnection]
                Resource: !Ref ConnectionArn
  Pipeline:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      Name: !Sub ${ProjectName}-pipeline
      RoleArn: !GetAtt PipelineRole.Arn
      ArtifactStore: { Type: S3, Location: !Ref ArtifactBucket }
      Stages:
        - Name: Source
          Actions:
            - Name: GitHubSource
              ActionTypeId: { Category: Source, Owner: AWS, Provider: CodeStarSourceConnection, Version: '1' }
              OutputArtifacts: [{ Name: SourceOutput }]
              Configuration:
                ConnectionArn: !Ref ConnectionArn
                FullRepositoryId: !Sub ${GitHubOwner}/${GitHubRepo}
                BranchName: !Ref GitHubBranch
                DetectChanges: true
        - Name: Build
          Actions:
            - Name: ContainerBuild
              ActionTypeId: { Category: Build, Owner: AWS, Provider: CodeBuild, Version: '1' }
              InputArtifacts: [{ Name: SourceOutput }]
              OutputArtifacts: [{ Name: BuildOutput }]
              Configuration: { ProjectName: !Ref CodeBuildProject }
        - Name: Deploy
          Actions:
            - Name: ECSDeploy
              ActionTypeId: { Category: Deploy, Owner: AWS, Provider: ECS, Version: '1' }
              InputArtifacts: [{ Name: BuildOutput }]
              Configuration:
                ClusterName: !Ref Cluster
                ServiceName: !Sub ${ProjectName}-api
                FileName: imagedefinitions.json
Outputs:
  RepositoryUri: { Value: !GetAtt EcrRepository.RepositoryUri }
  ClusterName: { Value: !Ref Cluster }
  ServiceName: { Value: !Sub ${ProjectName}-api }
  PipelineName: { Value: !Ref Pipeline }
